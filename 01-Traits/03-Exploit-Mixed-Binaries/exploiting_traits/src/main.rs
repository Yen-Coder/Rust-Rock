// src/main.rs
use std::panic;

// External C function declaration
extern "C" {
    fn bug(ptr: usize);
}

// Define the Animal trait
trait Animal {
    fn make_sound(&self) -> String;
}

// Cat implementation
struct Cat;

impl Animal for Cat {
    fn make_sound(&self) -> String {
        "meow".to_string()
    }
}

// Dog implementation  
struct Dog;

impl Animal for Dog {
    fn make_sound(&self) -> String {
        "woof".to_string()
    }
}

#[no_mangle]
pub extern "C" fn frust() {
    let dog: Dog = Dog;
    let cat: Cat = Cat;
    let mut v: Vec<Box<dyn Animal>> = Vec::new();
    
    v.push(Box::new(cat));
    v.push(Box::new(dog));
    
    println!("Created {} animals in vector", v.len());
    
    // First, let's see the animals work normally
    println!("\n=== Before corruption ===");
    for (i, animal) in v.iter().enumerate() {
        println!("Animal {}: {}", i, animal.make_sound());
    }
    
    unsafe {
        // Get the address of the trait object (fat pointer)
        let trait_obj_ptr = &*v[1] as *const dyn Animal;
        let x: usize = trait_obj_ptr as *const () as usize;
        
        println!("\n=== Calling vulnerable C function ===");
        println!("Trait object pointer: 0x{:x}", x);
        
        // Call the vulnerable C/C++ function
        bug(x);
    }
    
    println!("\n=== After corruption ===");
    println!("Attempting to call make_sound on potentially corrupted objects...");
    
    // This is where the exploit would trigger
    for (i, animal) in v.iter().enumerate() {
        println!("Calling make_sound on animal {}", i);
        
        // Use catch_unwind to handle potential crashes
        let result = panic::catch_unwind(panic::AssertUnwindSafe(|| {
            animal.make_sound()
        }));
        
        match result {
            Ok(sound) => println!("  Animal {} says: {}", i, sound),
            Err(_) => println!("  Animal {} crashed when calling make_sound! (VTable corrupted)", i),
        }
    }
}

fn main() {
    println!("VTable Corruption PoC - Exploiting Rust Traits");
    println!("===============================================");
    println!("This demonstrates how C/C++ code can corrupt Rust trait object vtables");
    println!();
    
    frust();
    
    println!();
    println!("===============================================");
    println!("PoC demonstration completed.");
    println!("Note: If the program crashed, that's expected behavior due to VTable corruption.");
}
